



open override func draw(context: CGContext, point: CGPoint)
{
    guard let label = label else { return }
    
    let offset = self.offsetForDrawing(atPoint: point)
    let size = self.size
    
    var rect = CGRect(
        origin: CGPoint(
            x: point.x + offset.x,
            y: point.y + offset.y),
        size: size)
    rect.origin.x -= size.width / 2.0
    rect.origin.y -= size.height
    
    context.saveGState()

    context.setFillColor(color.cgColor)

    if offset.y > 0
    {
        context.beginPath()
        context.move(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y + arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x + (rect.size.width - arrowSize.width) / 2.0,
            y: rect.origin.y + arrowSize.height))
        //arrow vertex
        context.addLine(to: CGPoint(
            x: point.x,
            y: point.y))
        context.addLine(to: CGPoint(
            x: rect.origin.x + (rect.size.width + arrowSize.width) / 2.0,
            y: rect.origin.y + arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x + rect.size.width,
            y: rect.origin.y + arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x + rect.size.width,
            y: rect.origin.y + rect.size.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y + rect.size.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y + arrowSize.height))
        context.fillPath()
    }
    else
    {
        context.beginPath()
        context.move(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y))
        context.addLine(to: CGPoint(
            x: rect.origin.x + rect.size.width,
            y: rect.origin.y))
        context.addLine(to: CGPoint(
            x: rect.origin.x + rect.size.width,
            y: rect.origin.y + rect.size.height - arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x + (rect.size.width + arrowSize.width) / 2.0,
            y: rect.origin.y + rect.size.height - arrowSize.height))
        //arrow vertex
        context.addLine(to: CGPoint(
            x: point.x,
            y: point.y))
        context.addLine(to: CGPoint(
            x: rect.origin.x + (rect.size.width - arrowSize.width) / 2.0,
            y: rect.origin.y + rect.size.height - arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y + rect.size.height - arrowSize.height))
        context.addLine(to: CGPoint(
            x: rect.origin.x,
            y: rect.origin.y))
        context.fillPath()
    }
    
    if offset.y > 0 {
        rect.origin.y += self.insets.top + arrowSize.height
    } else {
        rect.origin.y += self.insets.top
    }

    rect.size.height -= self.insets.top + self.insets.bottom
    
    UIGraphicsPushContext(context)
    
    label.draw(in: rect, withAttributes: _drawAttributes)
    
    UIGraphicsPopContext()
    
    context.restoreGState()
}


// Make font image

/*
 lazy var veggieItemView: UIImageView = {
     let img = "야".imageWith(fontSize: 14, width: 18, height: 18, textColor: .lightGray)
     let imageView = UIImageView(image: img)
     imageView.contentMode = .scaleAspectFit
     return imageView
     
 }()

 lazy var fruitItemView: UIImageView = {
     let img =  "과".imageWith(fontSize: 14, width: 18, height: 18, textColor: .lightGray)
     let imageView = UIImageView(image: img)
     imageView.contentMode = .scaleAspectFit
     return imageView
 }()

 func addIconView() {
     
     addSubViews(iconRing, ring1, ring2)
     bringSubviewToFront(iconRing)
    
     iconRing.snp.makeConstraints { (maker) in
         maker.top.equalTo(self)
         maker.centerX.equalTo(self.snp.centerX)
         maker.height.equalTo(43)
     }
     
     iconRing.addSubViews(veggieItemView, fruitItemView)
     
     veggieItemView.snp.makeConstraints {
         $0.top.equalTo(iconRing).offset(2)
         $0.leading.trailing.equalTo(iconRing)
         $0.height.equalTo(18)
    }
     
     fruitItemView.snp.makeConstraints {
         $0.top.equalTo(veggieItemView.snp.bottom).offset(5)
         $0.leading.trailing.equalTo(iconRing)
         $0.height.equalTo(18)
    }
     
//        iconRing.layer.borderWidth = 1
//        veggieItemView.layer.borderWidth = 1
//        fruitItemView.layer.borderWidth = 1

 }
 */

/// 2020.10.04 일

    func configureSegmentControl() {
        
        kindSegmentControl = UISegmentedControl(items: ["야채", "과일"])
        kindSegmentControl.selectedSegmentIndex = 0
        
        let width = 100
        view.addSubview(kindSegmentControl)
        
        kindSegmentControl.snp.makeConstraints { make in
            make.top.equalTo(view.safeAreaLayoutGuide.snp.top).offset(7)
            make.trailing.equalTo(view).offset(-20)
            make.width.equalTo(width)
            make.height.equalTo(30)
        }
    
        // Style the Segmented Control
        kindSegmentControl.layer.cornerRadius = 5.0  // Don't let background bleed
        kindSegmentControl.backgroundColor = ColorHex.iceBlue
        kindSegmentControl.tintColor = ColorHex.lightBlue

            // Add target action method
        kindSegmentControl.addTarget(self, action: #selector(changedIndexSegment), for: .valueChanged)
    }
